// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.revrobotics.*;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.wpilibj.drive.MecanumDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.RobotContainer;

public class Mecanum extends SubsystemBase {
  public CANSparkMax leftFront;
  public CANSparkMax leftRear;
  public static MotorControllerGroup m_left;

  public CANSparkMax rightFront;
  public CANSparkMax rightRear;
  public static MotorControllerGroup m_right;
  public MecanumDrive mecanumDrive;

  // Here's the layout:
  // 1  ^  3
  // 2  ^  4

  public static RelativeEncoder m_RLencoder;
  public static RelativeEncoder m_FLencoder;
  public static RelativeEncoder m_RRencoder;
  public static RelativeEncoder m_FRencoder;

  public Mecanum() {
    leftFront = new CANSparkMax(5, MotorType.kBrushless);
    leftFront.restoreFactoryDefaults();
    leftFront.setInverted(true);
    leftFront.setIdleMode(IdleMode.kCoast);
    leftFront.burnFlash();

    leftRear = new CANSparkMax(2, MotorType.kBrushless);
    leftRear.restoreFactoryDefaults();
    leftRear.setInverted(true);
    leftRear.setIdleMode(IdleMode.kCoast);
    leftRear.burnFlash();

    m_left = new MotorControllerGroup(leftFront, leftRear);

    rightFront = new CANSparkMax(3, MotorType.kBrushless);
    rightFront.restoreFactoryDefaults();
    rightFront.setInverted(false);
    rightFront.setIdleMode(IdleMode.kCoast);
    rightFront.burnFlash();

    rightRear = new CANSparkMax(4, MotorType.kBrushless);
    rightRear.restoreFactoryDefaults();
    rightRear.setInverted(false);
    rightRear.setIdleMode(IdleMode.kCoast);
    rightRear.burnFlash();

    mecanumDrive = new MecanumDrive(leftFront, leftRear, rightFront, rightRear);
    addChild("Mecanum Drive", mecanumDrive);
    mecanumDrive.setSafetyEnabled(true);
    mecanumDrive.setExpiration(0.1);
    mecanumDrive.setMaxOutput(1.0);
  }

  /**
   * Drive method for te mecanum base.
   *
   * <p>Uses driveCartesian as the driver.
   *
   * @param y Forward and back value, perhaps from a joystick.
   * @param x Right and left value, also perhaps from a joystick.
   * @param z Rotation value, from-AHA! You thought I was about to type "perhaps from a joystick!"
   *     You fool! It might come from a SEPERATE joystick, because a joystick only has 2 axes!
   */
  @Override
  public void periodic() {
    mecanumDrive.driveCartesian(
        RobotContainer.getJoystickYAxis() * RobotContainer.getMaxSpeed(),
        -RobotContainer.getJoystickXAxis() * RobotContainer.getMaxSpeed(),
        -RobotContainer.getJoystickZAxis() * RobotContainer.getMaxSpeed(),
        this.getYawAngle());
    SmartDashboard.putNumber("x axis", RobotContainer.getJoystickXAxis());
    SmartDashboard.putNumber("y axis", RobotContainer.getJoystickYAxis());
    SmartDashboard.putNumber("z axis", RobotContainer.getJoystickZAxis());
    SmartDashboard.putNumber("max speed", RobotContainer.getMaxSpeed());
  }

  public Rotation2d getYawAngle() {
    return Rotation2d.fromDegrees(PIDmecanum.gyro.getAngle());
  }

  @Override
  public void simulationPeriodic() {}
}
