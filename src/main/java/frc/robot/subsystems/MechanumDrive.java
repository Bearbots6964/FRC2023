// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.revrobotics.*;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.shuffleboard.SimpleWidget;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj.drive.MecanumDrive;
import edu.wpi.first.wpilibj.SerialPort;
import edu.wpi.first.util.function.FloatSupplier;
import edu.wpi.first.util.sendable.SendableBuilder;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.Timer;
import com.kauailabs.navx.frc.AHRS;

import frc.robot.RobotContainer;

public class MechanumDrive extends SubsystemBase {
    private CANSparkMax leftFront;
    private CANSparkMax leftRear;
    public MotorControllerGroup m_left;

    private CANSparkMax rightFront;
    private CANSparkMax rightRear;
    public MotorControllerGroup m_right;
    public MecanumDrive mecanumDrive;
    
    // Here's the layout:
    // 1  ^  3
    // 2  ^  4

    public static RelativeEncoder m_RLencoder;
    public static RelativeEncoder m_FLencoder;
    public static RelativeEncoder m_RRencoder;
    public static RelativeEncoder m_FRencoder;

    public static AHRS gyro;
    private Timer timer;
    private static double kP, kI, kD, P, I, D, errorSum, errorRate, lastTimeStamp, iLimit, lastError;
    public double tolerance, error; 
    private static boolean automate;
    public int count;

 /**
 * Drive method for te mecanum base.
 * 
 * <p>Uses driveCartesian as the driver.
 * @param y      Forward and back value, perhaps from a joystick.
 * @param x      Right and left value, also perhaps from a joystick.
 * @param z      Rotation value, from-AHA! You thought I was about to type "perhaps from a joystick!" You fool! It might come from a SEPERATE joystick, because a joystick only has 2 axes!
 */

@Override
public void periodic() {
  mecanumDrive.driveCartesian(RobotContainer.getJoystickYAxis(), -RobotContainer.getJoystickXAxis(), -RobotContainer.getJoystickZAxis());
  SmartDashboard.putNumber("pitch angle", gyro.getPitch());
  SmartDashboard.putNumber("x axis", RobotContainer.getJoystickXAxis());
  SmartDashboard.putNumber("y axis", RobotContainer.getJoystickYAxis());
  SmartDashboard.putNumber("z axis", RobotContainer.getJoystickZAxis());
}    

public MechanumDrive() {
leftFront = new CANSparkMax(5, MotorType.kBrushless);
leftFront.restoreFactoryDefaults() ;  
leftFront.setInverted(true);
leftFront.setIdleMode(IdleMode.kCoast);
leftFront.burnFlash();

leftRear = new CANSparkMax(2, MotorType.kBrushless);
leftRear.restoreFactoryDefaults();  
leftRear.setInverted(true);
leftRear.setIdleMode(IdleMode.kCoast);
leftRear.burnFlash();

m_left = new MotorControllerGroup(leftFront, leftRear);

rightFront = new CANSparkMax(3, MotorType.kBrushless);
rightFront.restoreFactoryDefaults();  
rightFront.setInverted(false);
rightFront.setIdleMode(IdleMode.kCoast);
rightFront.burnFlash();

rightRear = new CANSparkMax(4, MotorType.kBrushless);
rightRear.restoreFactoryDefaults();  
rightRear.setInverted(false);
rightRear.setIdleMode(IdleMode.kCoast);
rightRear.burnFlash();
  

mecanumDrive = new MecanumDrive(leftFront, leftRear, rightFront, rightRear);
addChild("Mecanum Drive",mecanumDrive);
mecanumDrive.setSafetyEnabled(true);
mecanumDrive.setExpiration(0.1);
mecanumDrive.setMaxOutput(1.0);

timer = new Timer();
automate = false;
kP = 0.18;
kI = 0.025;
kD = 0.3; 
tolerance = 0.5; 
iLimit = 2.0;
gyro = new AHRS(SPI.Port.kMXP);
}

public void runLeftFront(){
  leftFront.set(0.5);
}

public void preparePID(){
    while(gyro.getPitch() < 15){
      m_left.set(0.2);
      m_right.set(0.2);
    }
  }

  public void startPID(){
    switchToAuto();
    errorSum = 0;
    lastError = 0;
    timer.start();
    lastTimeStamp = timer.getFPGATimestamp();
    lastError = gyro.getPitch();
  }

  public double PID(){
     //integral
     if(Math.abs(error) < iLimit){
      errorSum += error;
    }

    //derivative
    double deltaT = timer.getFPGATimestamp() - lastTimeStamp;
    errorRate = (error - lastError) / deltaT;
    lastError = error;
    lastTimeStamp = timer.getFPGATimestamp();

    P = kP * error;
    I = kI * errorSum;
    D = kD * errorRate;

    double outputSpeed = P + I + D;

    return outputSpeed;
  }

  public void PIDDrive(){
    if(error > tolerance){
      m_left.set(this.PID());
      m_right.set(this.PID());
    }
    else{
      m_left.set(0);
      m_right.set(0);
    }
  }

  public void switchToAuto(){
    automate = true;
  }

  public void switchToJoystick(){
    automate = false;
  }
@Override
public void simulationPeriodic() {
    // This method will be called once per scheduler run when in simulation
}

// // Sendable class
// @Override
// public void initSendable(SendableBuilder builder) {
//   builder.setSmartDashboardType("Gyro");
//   builder.addFloatProperty("Pitch Angle", null, null);
// }
}